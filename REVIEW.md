# Ревью кода: Вейвлет-преобразование в реальном времени

## Общая оценка

Архитектура понятная: отдельные потоки для генерации сигнала и вейвлет-анализа, `RingBuffer` для истории, `ParamsModel` для потокобезопасных настроек. Есть несколько **критических багов** (потокобезопасность, FPS скейлограммы, шум при `seed != 0`) и ряд мест для улучшения.

---

## Критические проблемы

### 1. **GeneratorWorker: доступ к `engine.fs` и `engine.chunk_size` без блокировки**

В `main_window.py` (около 79–82):

```python
fs = float(self.engine.fs)
n = int(self.engine.chunk_size)
dt = max(0.001, n / fs)
```

Поток воркера читает эти поля напрямую, тогда как `SignalEngine` защищает их `_lock`. При изменении параметров в UI возможна гонка и некорректные `dt` / разная интерпретация `fs` в чанках.

**Рекомендация:** брать `fs` и `chunk_size` внутри `generate_chunk()` (уже под локом) или ввести `get_global()` в `SignalEngine` и использовать его из воркера.

---

### 2. **WaveletWorker: FPS скейлограммы не учитывается**

- Воркер крутит блокирующий цикл `while self._running: ... time.sleep(1/self._fps)` и **не обрабатывает эвенты Qt**.
- `set_fps` вызывается из UI по сигналу (queued). Слот выполняется в потоке воркера, но событийная петля там не крутится → **`set_fps` фактически никогда не вызывается**.
- Кроме того, воркер **не читает `scalogram_fps` из `params`**, а использует только свой `_fps` (по умолчанию 8).

В итоге изменение «FPS скейлограммы» в UI не имеет эффекта.

**Рекомендация:** убрать `set_fps` и брать FPS из `params.snapshot()` в каждой итерации цикла (как уже делается для `fs`, `view_window_sec` и т.п.), например:  
`fps = max(1, int(snap.get("scalogram_fps", 8)))`, затем `time.sleep(1.0 / fps)`.

---

### 3. **NoiseComponent: при `seed != 0` шум повторяется каждый чанк**

В `noise.py` при ненулевом `seed` на каждый чанк делается:

```python
self._rng = np.random.default_rng(seed)
return self._rng.normal(...)
```

RNG каждый раз инициализируется заново одним и тем же `seed`. В результате один и тот же кусок шума повторяется на каждом чанке (длиной `chunk_size`), вместо непрерывной реализации.

**Рекомендация:** инициализировать RNG один раз (при создании или при первом использовании `seed`). При `seed != 0` — фиксированный RNG, при `seed == 0` — `default_rng(None)`. Между чанками только вызывать `normal(...)`, не пересоздавать RNG.

---

### 4. **_apply_preset: небезопасная работа с `engine.components`**

В `_apply_preset`:

```python
self.engine.components.clear()
for c in data.get("components", []):
    self.engine.add_component(...)
```

- `components` меняется напрямую, без блокировки `SignalEngine`. Генератор в другом потоке в `generate_chunk` делает `comps = list(self.components)` под локом — возможна гонка при `clear` и последующем `add_component`.
- Публичный API движка не предполагает прямого изменения `components`.

**Рекомендация:** ввести в `SignalEngine` метод вида `replace_components(snap: list)` (под локом: clear + add по списку) и вызывать только его из `_apply_preset`. Либо `clear_components()` + цикл `add_component`, но вся мутация только внутри движка под `_lock`.

---

## Важные замечания

### 5. **Завершение потоков при закрытии приложения**

Генератор и вейвлет-воркеры работают в циклах `while self._running`. Флаг `_running` меняется только в `stop()`, но **`stop()` нигде не вызывается** (нет перехвата `closeEvent` и т.п.). При закрытии окна потоки продолжают работать до завершения процесса.

**Рекомендация:** реализовать `closeEvent`, останавливать воркеры (`stop`), дожидаться завершения потоков (`thread.quit()` + `thread.wait()` или аналог), затем закрывать окно.

---

### 6. **Дублирование логики осей Y скейлограммы**

Расчёт тиков по частотам (Гц) для скейлограммы делается и в `_update_scalogram`, и в `_refresh_scalo_y_ticks`. Код похож, его легко разнести при доработках.

**Рекомендация:** вынести общую часть в метод вида `_compute_hz_ticks(rows, freqs, view_range)` и использовать в обоих местах.

---

### 7. **CWT / DWT: нормализация и NaN**

- В CWT используется `np.nanmax` / `np.nanmean` / `np.nanstd`, в DWT — `np.max` / `np.mean` / `np.std`. Для единообразия и устойчивости к выбросам в DWT тоже можно использовать `nan*`, либо явно задокументировать, почему только в CWT.
- В CWT при `normalize == "zscore"` проверяется `sd > 0`; при `sd == 0` картинка не меняется. Имеет смысл явно обработать случай постоянного поля (например, не нормализовать или выводить предупреждение в лог).

---

### 8. **`amplitude_clip` в SignalEngine**

Поле есть и используется в `generate_chunk`, но **нигде не задаётся** (всегда 0) и не выводится в UI. По сути неиспользуемая возможность.

**Рекомендация:** либо добавить в параметры и UI, либо удалить, чтобы не раздувать код.

---

### 9. **GaussPulseComponent: ограничение числа импульсов в чанке**

Для повторяющихся импульсов (`repetition_period_sec > 0`) в чанке учитываются только центры в диапазоне `dk in (-2, 3)` относительно `k0`. При большом `chunk_size` или малом периоде часть импульсов может не попасть в расчёт.

**Рекомендация:** задать формулой, сколько периодов пересекает чанк, и строить `centers` для всех таких периодов, либо явно ограничить и описать это в документации/подсказках.

---

### 10. **PyWavelets: `shan1-1.5`**

В CWT используется вейвлет `"shan1-1.5"`. Нужно убедиться, что PyWavelets поддерживает именно такую строку (и соответствующий параметризованный вейвлет). При несовпадении возможны ошибки при выборе этого пункта.

---

## Рекомендации по оптимизации

### 11. **Типы и буферы**

- Везде используется `np.float32` — хорошо для памяти и кэша.
- `RingBuffer.get_last` каждый раз возвращает `.copy()`. Для больших `n` и частых вызовов можно рассмотреть вариант с предвыделенным буфером и копированием в него, чтобы снизить аллокации, но только при профилировании.

### 12. **Вейвлет в отдельном потоке**

CWT/DWT выполняются в потоке воркера, главный поток не блокируется — архитектура удачная. Дальнейшие оптимизации — уже внутри PyWavelets (или замена на C++/CUDA), о чём ниже.

### 13. **Планирование на будущее: C++ и COM-порт**

- **C++:** Для тяжёлых вычислений (CWT, длинные сигналы) перенос ядра на C++ (например, pybind11) даст выигрыш. Имеет смысл выделить четкий C API для «чанк сигнала → скейлограмма» и держать UI и бизнес-логику в Python.
- **COM-порт:** Вынести чтение в отдельный поток/сервис и писать в тот же `RingBuffer` (или аналог). Текущая схема «генератор → кольцевой буфер → вейвлет» хорошо ложится на режим «COM → буфер → вейвлет» при переключении источника сигнала. Добавить:
  - настройки COM (порт, baud rate, и т.д.) в `ParamsModel` или отдельную модель;
  - переключатель «источник: генератор / COM»;
  - воркер чтения COM → `ring.append(chunk)` по мере прихода данных.

---

## Что сделано хорошо

- Разделение генерации, буфера, вейвлета и UI по разным модулям и потокам.
- Потокобезопасные `ParamsModel`, `RingBuffer`, `RealtimeClock`.
- Плагинная система вейвлетов и компонентов сигнала.
- Схема параметров (`ParamSpec`) и форма из неё.
- Сглаживание параметров синуса (`smooth_ms`), коррекция времени для chirp/rect/gauss.
- Экспорт пресетов, CSV/NPY, PNG скейлограммы.
- Ограничение колёсика мыши для спинбоксов (`_NoWheelUnlessFocused`).

---

## Краткий чек-лист исправлений

| # | Проблема | Действие |
|---|----------|----------|
| 1 | Генератор читает `fs`/`chunk_size` без лока | Добавить `get_global()` / использовать данные из `generate_chunk` |
| 2 | FPS скейлограммы не применяется | Читать FPS из `params.snapshot()`, убрать `set_fps` |
| 3 | Шум с `seed != 0` повторяется по чанкам | Инициализировать RNG один раз, не пересоздавать на каждый чанк |
| 4 | `_apply_preset` мутирует `engine.components` | Ввести `replace_components` (или аналог) в движок, вызывать только его |
| 5 | Потоки не останавливаются при закрытии | `closeEvent` → stop воркеров → wait потоков |
| 6 | Дублирование расчёта тиков Y | Вынести общий код в `_compute_hz_ticks` |
| 7 | CWT/DWT нормализация | Унифицировать nan* при необходимости, обработать `sd == 0` |
| 8 | `amplitude_clip` не используется | Добавить в UI или удалить |
| 9 | Gauss pulse центры | Уточнить расчёт числа импульсов в чанке |
| 10 | `shan1-1.5` | Проверить поддержку в PyWavelets |

---

## Внесённые исправления (в коде)

- **№1** — В `SignalEngine` добавлен `get_global()`; `GeneratorWorker` использует его вместо прямого чтения `engine.fs` / `engine.chunk_size`.
- **№2** — `WaveletWorker` берёт `scalogram_fps` из `params.snapshot()` в каждой итерации; `set_fps` и слот удалены. FPS скейлограммы меняется в реальном времени.
- **№3** — В `NoiseComponent` RNG создаётся один раз; при смене `seed` в параметрах RNG переинициализируется, но не на каждый чанк. Шум с `seed != 0` идёт непрерывно и воспроизводимо.
- **№4** — В `SignalEngine` добавлен `replace_components(snap)`; `_apply_preset` вызывает только его вместо прямого `engine.components.clear()` и цикла `add_component`.
- **№5** — Реализован `closeEvent`: останавливается UI-таймер, вызывается `stop()` у обоих воркеров, `quit()` + `wait(3000)` для потоков, затем закрытие окна.
- **№7** — В CWT и DWT унифицирована нормализация: `nanmax` / `nanmean` / `nanstd`, проверка `sd > 1e-9` для zscore, учёт `img.size` при max.

Проверка: после изменений линтер не сообщает ошибок. Запуск через `run.bat` или `python main.py` для ручной проверки.

---

## Высокочастотный режим и оптимизации (дополнение)

### Повышенные лимиты

- **fs:** 100 – 2 000 000 Гц (частота дискретизации).
- **Чанк:** 64 – 131 072 отсчётов.
- **Окно просмотра:** 0.1 – 300 с.
- **FPS скейлограммы:** 1 – 120.
- **CWT:** число частотных бинов 8 – 4096 (шаг 8), default 128; f_min/f_max до 10 МГц.
- **DWT/WPT:** maxlevel и wpt_level 1 – 14; top_k 1 – 256.
- **Синус / чирп:** максимальная частота до 10 МГц.
- **Кольцевой буфер:** история 60 с (вместо 20).

### Оптимизации

- **Генератор:** предвыделенный буфер `_chunk_buf` (MAX_CHUNK = 131 072), без `np.zeros(n)` на каждый чанк; `np.clip(..., out=x)` по месту.
- **CWT:** входной массив делается контигуальным через `np.require(..., requirements='C')` перед `pywt.cwt`.
- **Вейвлет-воркер:** окно для CWT ограничено `MAX_WAVELET_SAMPLES = 2**22` (4 М отсчётов), чтобы не перегружать при больших fs × window.
- **Графики:** `antialias=False`. Для ускорения можно попробовать `pg.setConfigOptions(useOpenGL=True)` (иногда нестабильно).
